// ----------------------------------------------
// A script to solve the N-Queens problem,
// a problem whereby no queen should be attacked
// by another queen.
// For example, for 8-queens, the solution might
// eventually be:
//
// [- - - - - - Q -]
// [- - - Q - - - -]
// [- Q - - - - - -]
// [- - - - - - - Q]
// [- - - - - Q - -]
// [Q - - - - - - -]
// [- - Q - - - - -]
// [- - - - Q - - -]
// ----------------------------------------------

returnable list initialize -> rep {
    
    // build the representation
    args 0 -> stringN;
    integer stringN -> N;
    list [] -> rep;
    integer 0 -> i;
    // board initialization with heuristic
    repeat N times {
        string i -> istring;
        add_token(istring, rep);
        integer (i + 2) -> i;
        if(i == N) {
            integer 0 -> i;
        }
    }
    release i;
    release stringN;
    release istring;

    return rep;

}

block showBoard {

    // create one of the rows of the board
    list [] -> row;
    repeat N times {
        add_token ("-", row);
    }

    // create the board representation
    integer 0 -> i;
    repeat N times {
        // make sure correct '-' is set with a 'Q'
        get_token(i, representation) -> token;

        // token is a string to needs to be 
        // converted to an integer
        integer token -> itoken;

        // now set the token to a 'Q'
        set_token(itoken, row, "Q") -> theRow;

        // iterate to next row
        integer (i + 1) -> i;

        // print the row out
        echo_nl theRow;
    }

}

// computes the error of the board
returnable integer computeError -> theError {

    integer 0 -> theError;

    // compute the number of queens attacking each queen
    integer 0 -> i;
    repeat N times {
        get_token(i, representation) -> token;
        integer token -> itoken;
        integer 0 -> e;
        integer 0 -> k;
        repeat N times {
            get_token(k, representation) -> token;
            integer token -> ktoken;
            if (itoken == ktoken) {
                if ( i != k) {
                    integer (e + 1) -> e;
                }
            }
            if (k < i) {
                if(ktoken == (itoken - (i - k))) {
                    integer (e + 1) -> e;
                } else {
                    if(ktoken == (itoken - (k - i))) {
                        integer (e + 1) -> e;
                    }
                }
            } else {
                if (k > i) {
                    if(ktoken == (itoken + (k - i))) {
                        integer (e + 1) -> e;
                    } else {
                        if(ktoken == (itoken + (i - k))) {
                            integer (e + 1) -> e;
                        }
                    }
                }
            }
            integer (k + 1) -> k;
        }
        integer (i + 1) -> i;
        integer (theError + e) -> theError;
    }
    return theError;
}

start {

    // initialize the representation 
    call initialize -> representation;

    // find out what initial error is. Note, we can
    // see that the returnable computeError returns
    // an integer so the car 'error' is implicitly
    // set to an integer type
    call computeError -> error;

    // minimize error
    integer error -> currentError;
    integer 1 -> moveBy;
    while (currentError != 0) {
        integer 0 -> count;
        repeat N times {
            get_token(count, representation) -> tok;
            integer tok -> itok;
            list representation -> oldRep;
            if((itok + moveBy) >= N) {
                integer ((itok + moveBy) % (N - 1)) -> amount;
                string amount -> strtok;
                set_token(count, representation, strtok) -> representation;
            } else {
                integer (itok + moveBy) -> itok;
                string itok -> strtok;
                set_token(count, representation, strtok) -> representation;
            }
            
            // now compute new error based on update
            call computeError -> error;

            // now based on update decide whether to keep or go
            // back to original
            if(error <= currentError) {
                integer error -> currentError;
            } else {
                list oldRep -> representation;   
            }

            integer (N - 1) -> value;
            random_int(value) -> randomValue;
            integer (moveBy + randomValue) -> moveBy;
            if(moveBy >= (N - 1)) {
                integer 1 -> moveBy;
            }

            integer (count + 1) -> count;
        }
        
        echo "Error: ";
        echo_nl currentError;
    }

    // print out the board representation
    call showBoard;

}
